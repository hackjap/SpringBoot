   
### 프레임 워크 vs 라이브러리 
- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 그것은 프레임워크가 맞다(JUnit)
- 반면에 내가 작성한 코드를 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.


## DI

> 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.

- 의존관계 주입을 사용하면 정적인 클래스의 의존 관계르 변경하지 않고 동적인객체 인스턴스 의존관계를 쉽게 변경할 수 있다.


### IoC 컨테이너 , DI 컨테이너 

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 "DI 컨테이너"라 한다.


### 스프링 컨테이너 생성
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);    // 스프링 컨테이너 생성
 


## ApllicationContext가 제공하는 부가기능

### 메시지 소스를 활용한 국제화 기능

### 환경변수

### 애플리케이션 이벤트

### 변리한 리소스 조회

### 정리
- ApplicationContext는 BeanFactory의 기능을 상속받는다
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능 제공
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFacotry나 ApplicationContext를 스프링 컨테이너라 한다.


### 다양한 설정 형식 지원 - 자바코드,XML
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계
    - 자바코드, XML , Groovy 등

  
## 싱글톤 패턴

### 싱글톤 패턴의 개요
- 트래픽이 많으면 그 만큼 객체가 생성되고 메모리 낭비가 심하다.
- 따라서 싱글톤 패턴을 사용하여 객체를 공유하도록 설계

### 싱글톤패턴이란?
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함.
  - private 새성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 함
  
  >    // 딱 1개의 객체 인스턴스만 존재해야 하므로 생성자를 private로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.

### 싱글톤 패턴의 문제점
- 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스의 의존(DIP위반)
- 클라이언트가 구체 클래스에 의존해서 OCP원칙을 위반할 가능성 높다.

## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해곃하면서, 객체 인스턴스를 싱글톤으로 관리한다.
- 지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈


### 싱글톤 방식의 문제점 
- 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계 하면 안된다.
- 무상태(stateless)로 설계
  - 특정 클라이언트에 의존적인 필드 x
  - 값을 변경하는 필드 x
  - !! 진짜 공유 필드는 조심해야 한다! 스프링 빈은 항상 무상태로 설계
    - 실무에서 자주 겪는 문제점 
  
### 정리
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지는 않는다.
 - memberRepository()처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 떄 싱글 톤을 보장하지는 않는다.
- 크게 고민할 것이 없다. 스프링 설정 정보는 항상 @Configuration 을 사용하자 .



## 컴포넌트 스캔과 의존관계 자동 주입 시작하기 

- 설정 정보에 직접 등록하면 비효율적 ->@Autowired 기능을 이용하여 자동 주입 



### 컴포넌트 스캔 주의점 
 - 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
 - 빈 이름 기본 전략 : MemberServiceImp 클래스 - > memberServiceImpl
 - 빈 이름 직접 지정 : 만약 스프링 빈의 이름을 직접 지정하고 싶으면 @Component("memberService2") 이런식으로 이름을 부여하면 된다.

### @AutoWired 의존 관계 자동주입
- 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입
  - getBean(MemberRepository.class)와 동일하다고 이해하면 됨 

### 탐색 위치와 기본대상 지성
- basePakages : 탐색할 패키지의 시작위치를 지정. 여러 개도 지정 가능 
- 만약 지정하지 않으면, @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작위치
| com.hell(프로젝트 시작 루트)에 AppConfig 같은 메인 설정 정보를 두고, @ComponentScan 에노테이션을 붙이고 , basepakages 지정은 생략


### 컴포넌트 스캔 기본 대상
- @Component : 컴포넌트 스캔에서 사용 
- @Controller : 스프링 MVC 컨트롤러에서 사용 -> 스프링 MVC 컨트롤러로 인식
- @Service : 스프링 비즈니스 로직에서 사용 -> 특별한 처리를 하지는 않지만, 개발자들이 핵심 비즈니스 로직이 인지하도록 도움을 준다.
- @Repository : 스프링 데이터 접근 계층에서 사용 -> 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 스프링 설정 정보에서 사용 -> 스프링 설정 정보로 인식하고 싱글톤을 유지하도록 추가 처리

※ 사실 에노테이션에는 상속 관계라는 것이 없다. 에노테이션을 인식하는 것은 스프링이 지원하는 기능 


### 중복 등록과 충돌


## 의존 관계 자동 주입

---

### 다양한 의존 관계 주입 방법
- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입 

### 생성자 주입
- 이름 그대로 생성자를 통해서 의존 관게를 주입하는 방법 
- 생성자 호출시점에 딱 1번만 호출되는 것이 보장됨
- "불변, 필수" 의존관계에 사용
 
> ※ 생성자가 1개만 있으면 @Autowired를 생략해도 자동 주입 된다.

### 수정자 주입
- setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법
- "선택, 변경" 가능성이 있는 의존 관계에서 사용( @Autowired(require = false ) )
- 자바빈 프로버티 규약의 수정자 메서드 방식을 사용하는 방법(setAge)
 
### 필드 주입 
> @Autowired private MemberRepository memberRepository;
- 코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기에 힘들다는 치명적인 단점이 있음
- DI 프레임워크가 없으면 아무것도 없음
- 테스트 코드 이외엔 사용하지 말자

### 일반 메서드 주입 
- 한번에 여러 필드를 주입 받을 수 있다.
- 일반적으로 잘 사용하지 않는다.

> 스프링 빈이 아닌 Member클래스에서 @Autowired 코드를 적용해도 아무 기능도 동작하지 않는다.

### 옵션 처리 


## 생성자 주입 선택
- 최근에는 스프링을 포함한 DI 프레임워크 대부분은 생성자 주입을 권장
### 불변
- 대부분의 의존관계 주입은 한번 일어나면 앱 종료시점까지 의존관계를 변경할 일이 없음 
- 수정자 주입을 사용하면 setXXX 메서드를 public으로 열어두어야 함  
- 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 x 
- 생성자 주입은 객체를 생성할 때 닥 1번만 호출되므로 이후에는 호출 x. 불변하게 설계할 수 있음

### 누락
 - 프레임워크 없이 순수한 자바 코드를 단위 테스트하는 경우에 

### final 키워드
- 생성자 주입을 사용하면 final 키워드를 사용할 수 있음
- 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.

### 정리
- 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바의 언어의 특정을 잘 살리는 방법
- 기본적으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 됨. 동시에는 사용 불가
- 항상 생성자 주입을 선택!. 옵션이 필요하면 수정자 주입, 필드 주입은 x 

## 롬복과 최신 트렌드

--- 

### 개요
- 막상 개발을 하다보면 다 불편이고 생성자 주입을 사용. 하지만, 코드가 길어짐
- 따라서 코드를 최적화할 수 있는 롬복을 사용 

### lombok 설정방법
- file > settings > plugin > lombok
- compiler > annotation processors >  enable annotation processing 체크 
  
### 롬복 예시
    @Getter
    @Setter
    @NoArgsConstructor
    @ToString 

    @RequiredArgsConstructor 
    public OrderServiceImpl(MemberRepository memoryRepository, DiscountPolicy discountPolicy) {
    this.memberRepository = memoryRepository;
    this.discountPolicy = discountPolicy;
    }

## 조회 빈이 2개 이상 - 문제


### Autowired 매칭 정리 
1. 타입 매칭
2. 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭

### Qualifier 사용
- 주입시 추가적인 방법을 제공하는 것이지 이름을 변경하는 것이아니다.
- @Qualifire는 Qualifier를 찾는 용도로만 사용하는게 명확하고 좋음 

### Primary 사용
- @Primary는 우선순위를 정하는 방법이다.
- @Autowired 시에 여러 번 매칭되면 @Primary가 우선권을 가진다.
- 자세한 것이 우선순위를 정한다.


### 에노테이션 만들기

### 조회한 빈이 모두 필요할 때 List,Map
- 예를들어 할인의 종류(Rate,Fix)가 둘다 필요할 때
  

## 빈 생명주기 콜백 시작 
- 데이터베이스 커넥션 풀이나 네트워크 소켓처럼 앱 시작 시점에 필요한 연결을 미리 해두고 종료시점에 연결을 모두 종류하는 작업을 진행하려면 초기화와 종료 작업이 필요
- 객체 생성 -> 의존관계 주입 따라서, 초기화작업은 의존관계 주입이 모두 완료되고 난 다음에 호출

###  스프링 빈의 이벤트 라이프 사이클
- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료 
- 초기화 콜백 : 빈이 생성되고 빈의 의존관계 주입이 완료된 후 호출 , 소멸전 콜백 : 빈이 소멸되기 직전에 호출 

> 참고 : 객체의 생성과 초기화를 분리하자.!

- Initaionlizatoin 

### @Bean 설정정보사용
- 메서드 이름 자유 
- 스프링 빈이 스프링 코드 의존 x
- @Bean의 destoryMethod의 기본값이 inferred(추론) => close, shutdown(종료) 메서드를 자동 호출 
> @Bean(initMethod = "init", destroyMethod = "close")

### 에노테이션
| @PostConstruct, @PreDestroy
- 스프링에 종속적인 기술이 아니라 자바 표준 
- 외부 라이브러리에는 적용하지 못해 그떄는 @Bean의 기능을 사용

### 정리
- 그냥 에노테이션을 사용하자
- 코드를 고칠 수 없는 외부 라이브러리를 초기화 , 종료 하면 @bean을 사용 

## 빈 스코프 

### 스코프의 종류 
- 싱글톤 
- 프로토 타입
- 웹 관련 스코프 
  - request
  - session
  - application : 
  

### 프로토 타입 스코프 - 싱글톤 빈과 함께 사용시 문제점

### 프르토타입 스코프 - 싱글틴 빈과 함께 사용시 Provider로 문제 해결
- 지정한 프로토타입 빈이 생성되는 것을 확인할 수 있다.
- @ObjectFactory, @ObjectProvider 
- 필요한 DL(Dependancy Lookup) 정도의 기능을 제공
- 스프링의 의존한다는 단점

### JSR-330 provider
  implementation 'javax.inject:javax.inject:1'
- get() 메서드 하나로 기능이 매우 단순
- 별도의 라이브러리가 필요하다는 단점

### 정리
- 그런데 실무에서는 프로토타입을 직접적으로 사용하는 일은 매우 드물다.
- ObjectProvider, JSR303 Provider 등은 프로토타입 뿐만 아니라 DL이 필요한 경우에는 언제든지 사용할 수 있다.

## 웹 스코프

### 웹 스코프의 특징
- 웹 스코프는 웹 환경에서만 동작
- 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리. 따라서 종료 메서드가 호출 

### 웹 스코프의 종류
- request
- session
- application
- websocket


### request 스코프 예제 만들기 
- 스프링 인터셉터 , 서블릿 필터 
> >@Scope(value = "request",proxyMode = ScopedProxyMode.TARGET_CLASS )

## Proxy
### 동작원리
- CGLIB라는 라이브러리 내 클래스를 상속받은 가자 프록시 객체를 만들어서 주입
- 이 가짜 프록시 객체는 실제 요청이 오면 그떄 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.
- 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤 처럼 동작 

### 특징정리
- 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있음
- 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
- 단지 에노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다. 

