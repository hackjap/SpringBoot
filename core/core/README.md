   
### 프레임 워크 vs 라이브러리 
- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 그것은 프레임워크가 맞다(JUnit)
- 반면에 내가 작성한 코드를 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.


## DI

> 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.

- 의존관계 주입을 사용하면 정적인 클래스의 의존 관계르 변경하지 않고 동적인객체 인스턴스 의존관계를 쉽게 변경할 수 있다.


### IoC 컨테이너 , DI 컨테이너 

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 "DI 컨테이너"라 한다.


### 스프링 컨테이너 생성
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);    // 스프링 컨테이너 생성
 


## ApllicationContext가 제공하는 부가기능

### 메시지 소스를 활용한 국제화 기능

### 환경변수

### 애플리케이션 이벤트

### 변리한 리소스 조회

### 정리
- ApplicationContext는 BeanFactory의 기능을 상속받는다
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능 제공
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFacotry나 ApplicationContext를 스프링 컨테이너라 한다.


### 다양한 설정 형식 지원 - 자바코드,XML
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계
    - 자바코드, XML , Groovy 등

  
## 싱글톤 패턴

### 싱글톤 패턴의 개요
- 트래픽이 많으면 그 만큼 객체가 생성되고 메모리 낭비가 심하다.
- 따라서 싱글톤 패턴을 사용하여 객체를 공유하도록 설계

### 싱글톤패턴이란?
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함.
  - private 새성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 함
  
  >    // 딱 1개의 객체 인스턴스만 존재해야 하므로 생성자를 private로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.

### 싱글톤 패턴의 문제점
- 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스의 의존(DIP위반)
- 클라이언트가 구체 클래스에 의존해서 OCP원칙을 위반할 가능성 높다.

## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해곃하면서, 객체 인스턴스를 싱글톤으로 관리한다.
- 지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈


### 싱글톤 방식의 문제점 
- 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계 하면 안된다.
- 무상태(stateless)로 설계
  - 특정 클라이언트에 의존적인 필드 x
  - 값을 변경하는 필드 x
  - !! 진짜 공유 필드는 조심해야 한다! 스프링 빈은 항상 무상태로 설계
    - 실무에서 자주 겪는 문제점 
  
### 정리
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지는 않는다.
 - memberRepository()처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 떄 싱글 톤을 보장하지는 않는다.
- 크게 고민할 것이 없다. 스프링 설정 정보는 항상 @Configuration 을 사용하자 .
  


