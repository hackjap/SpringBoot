   
### 프레임 워크 vs 라이브러리 
- 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 그것은 프레임워크가 맞다(JUnit)
- 반면에 내가 작성한 코드를 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.


## DI

> 의존관계는 정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.

- 의존관계 주입을 사용하면 정적인 클래스의 의존 관계르 변경하지 않고 동적인객체 인스턴스 의존관계를 쉽게 변경할 수 있다.


### IoC 컨테이너 , DI 컨테이너 

- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 "DI 컨테이너"라 한다.


### 스프링 컨테이너 생성
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);    // 스프링 컨테이너 생성
 


## ApllicationContext가 제공하는 부가기능

### 메시지 소스를 활용한 국제화 기능

### 환경변수

### 애플리케이션 이벤트

### 변리한 리소스 조회

### 정리
- ApplicationContext는 BeanFactory의 기능을 상속받는다
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능 제공
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFacotry나 ApplicationContext를 스프링 컨테이너라 한다.


### 다양한 설정 형식 지원 - 자바코드,XML
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계
    - 자바코드, XML , Groovy 등

  
## 싱글톤 패턴

### 싱글톤 패턴의 개요
- 트래픽이 많으면 그 만큼 객체가 생성되고 메모리 낭비가 심하다.
- 따라서 싱글톤 패턴을 사용하여 객체를 공유하도록 설계

### 싱글톤패턴이란?
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함.
  - private 새성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 함
  
  >    // 딱 1개의 객체 인스턴스만 존재해야 하므로 생성자를 private로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.

### 싱글톤 패턴의 문제점
- 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스의 의존(DIP위반)
- 클라이언트가 구체 클래스에 의존해서 OCP원칙을 위반할 가능성 높다.

## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해곃하면서, 객체 인스턴스를 싱글톤으로 관리한다.
- 지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈


### 싱글톤 방식의 문제점 
- 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계 하면 안된다.
- 무상태(stateless)로 설계
  - 특정 클라이언트에 의존적인 필드 x
  - 값을 변경하는 필드 x
  - !! 진짜 공유 필드는 조심해야 한다! 스프링 빈은 항상 무상태로 설계
    - 실무에서 자주 겪는 문제점 
  
### 정리
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지는 않는다.
 - memberRepository()처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 떄 싱글 톤을 보장하지는 않는다.
- 크게 고민할 것이 없다. 스프링 설정 정보는 항상 @Configuration 을 사용하자 .



## 컴포넌트 스캔과 의존관계 자동 주입 시작하기 

- 설정 정보에 직접 등록하면 비효율적 ->@Autowired 기능을 이용하여 자동 주입 



### 컴포넌트 스캔 주의점 
 - 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
 - 빈 이름 기본 전략 : MemberServiceImp 클래스 - > memberServiceImpl
 - 빈 이름 직접 지정 : 만약 스프링 빈의 이름을 직접 지정하고 싶으면 @Component("memberService2") 이런식으로 이름을 부여하면 된다.

### @AutoWired 의존 관계 자동주입
- 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입
  - getBean(MemberRepository.class)와 동일하다고 이해하면 됨 

### 탐색 위치와 기본대상 지성
- basePakages : 탐색할 패키지의 시작위치를 지정. 여러 개도 지정 가능 
- 만약 지정하지 않으면, @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작위치
| com.hell(프로젝트 시작 루트)에 AppConfig 같은 메인 설정 정보를 두고, @ComponentScan 에노테이션을 붙이고 , basepakages 지정은 생략


### 컴포넌트 스캔 기본 대상
- @Component : 컴포넌트 스캔에서 사용 
- @Controller : 스프링 MVC 컨트롤러에서 사용 -> 스프링 MVC 컨트롤러로 인식
- @Service : 스프링 비즈니스 로직에서 사용 -> 특별한 처리를 하지는 않지만, 개발자들이 핵심 비즈니스 로직이 인지하도록 도움을 준다.
- @Repository : 스프링 데이터 접근 계층에서 사용 -> 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 스프링 설정 정보에서 사용 -> 스프링 설정 정보로 인식하고 싱글톤을 유지하도록 추가 처리

※ 사실 에노테이션에는 상속 관계라는 것이 없다. 에노테이션을 인식하는 것은 스프링이 지원하는 기능 


### 중복 등록과 충돌

##


